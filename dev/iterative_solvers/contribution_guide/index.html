<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Iterative Solvers · TrialDocs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TrialDocs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Contribution Guide</span><ul><li class="current"><a class="toctext" href>Iterative Solvers</a><ul class="internal"><li><a class="toctext" href="#Basic-Template-for-an-Iterative-Solver-1">Basic Template for an Iterative Solver</a></li><li><a class="toctext" href="#Struct-1">Struct</a></li><li><a class="toctext" href="#Constructor-1">Constructor</a></li><li><a class="toctext" href="#Initialize-Function-1">Initialize Function</a></li><li><a class="toctext" href="#Iteration-Function-1">Iteration Function</a></li><li><a class="toctext" href="#CliMa-Specific-Considerations-1">CliMa Specific Considerations</a></li><li><a class="toctext" href="#Preconditioners-1">Preconditioners</a></li><li><a class="toctext" href="#Writing-Tests-1">Writing Tests</a></li><li><a class="toctext" href="#Performance-Checks-1">Performance Checks</a></li><li><a class="toctext" href="#Conventions-1">Conventions</a></li></ul></li><li><a class="toctext" href="../../time_steppers/contribution_guide/">Time Stepping</a></li></ul></li><li><a class="toctext" href="../../function_index/">Function Index</a></li></ul></nav><article id="docs"><header><nav><ul><li>Contribution Guide</li><li><a href>Iterative Solvers</a></li></ul><a class="edit-page" href="https://github.com/sandreza/TrialDocs/blob/master/docs/src/iterative_solvers/contribution_guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Iterative Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Contribution-Guide-for-Abstract-Iterative-Solvers-1" href="#Contribution-Guide-for-Abstract-Iterative-Solvers-1">Contribution Guide for Abstract Iterative Solvers</a></h1><p>An abstract iterative solver is a module that needs one struct, one constructor, and two functions (initialize! and doiteration!), in order to interface with the rest of <a href="https://github.com/climate-machine">CliMa</a>. In what follows we will describe in detail the function signatures, return values, and struct properties necessary to build with <a href="https://github.com/climate-machine">CliMa</a>.</p><h2><a class="nav-anchor" id="Basic-Template-for-an-Iterative-Solver-1" href="#Basic-Template-for-an-Iterative-Solver-1">Basic Template for an Iterative Solver</a></h2><p>A basic template of an iterative solver could be as follows:</p><pre><code class="language-julia">module MyIterativeMethodSolver

export MyIterativeMethod

using ..LinearSolvers
const LS = LinearSolvers

# struct
struct MyIterativeMethod{FT} &lt;: LS.AbstractIterativeLinearSolver
  # minimum
  rtol::FT
  atol::FT
  # Add more structure if necessary
end

# constructor
function MyIterativeMethod(args...)
  # body of constructor
  return MyIterativeMethod(contructor_args...)
end

# initialize function (1)
function LS.initialize!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, args...)
  # body of initialize function in abstract iterative solver
  return Bool, Int
end

# iteration function (2)
function LS.doiteration!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, threshold, args...)
  # body of iteration
  return Bool, Int, Float
end

end # end of module</code></pre><p>MyIterativeMethod and function bodies would need to be replaced appropriately for a particular implementation. We will describe each component in detail in subsequent sections.</p><h2><a class="nav-anchor" id="Struct-1" href="#Struct-1">Struct</a></h2><p>A subset of AbstractIterativeLinearSolver needs at least two members: atol and rtol. The former represents an absolute tolerance and the latter is a relative tolerance. Both can be used to terminate the iteration to determine the convergence criteria. An example struct could be</p><pre><code class="language-julia">struct MyIterativeMethod{FT} &lt;: LS.AbstractIterativeLinearSolver
  atol::FT
  rtol::FT
end</code></pre><p>but often has more depending on the kind of iterative solver being used.  For example, in a <a href="https://en.wikipedia.org/wiki/Krylov_subspace">Krylov Subspace</a> method one would need to store a number of vectors which constitute the Krylov subspace.</p><h2><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h2><p>The constructor for the struct can be defined any number of ways depending on the needs of the struct itself. Often times this is just used to allocate memory or convergence thresholds. This can also be a good place to define structures that make the iterative solver easier to work with. For example, for a columnwise solver one would want an easy array structure to work with vectors in a columnwise fashion.</p><p>In <a href="#Basic-Template-for-an-Iterative-Solver-1">Basic Template for an Iterative Solver</a> we used an outer constructor, e.g.,</p><pre><code class="language-julia"># constructor
function MyIterativeMethod(args...)
  # body of constructor
  return MyIterativeMethod(contructor_args...)
end</code></pre><p>but we could have also used an inner constructor if desired.</p><h2><a class="nav-anchor" id="Initialize-Function-1" href="#Initialize-Function-1">Initialize Function</a></h2><p>The initialize function needs the following signature</p><pre><code class="language-none">function LS.initialize!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, args...)
  # body of initialize function in abstract iterative solver
  return Bool, Int
end</code></pre><h3><a class="nav-anchor" id="Arguments-1" href="#Arguments-1">Arguments</a></h3><ul><li>linearoperator!: A function that is assumed to have the following signature</li></ul><pre><code class="language-julia">linearoperator!(y, x, args...)
  # body of linear operator
  return nothing
end</code></pre><p>This represents the action of a linear operator L on a vector x, that stores the value in the vector y, i.e. Lx = y. The last argument (the args...) is necessary due to how linear operators are defined in CliMa. For example, see the IMEX METHODS.</p><ul><li>Q: An array</li><li>Qrhs: An array</li><li>solver: This is used for dispatch onto whatever abstract iterative solver that is defined</li><li>args...: This is passed into the linearoperator! function in other parts of the CliMa code. For example, see the IMEX METHODS.</li></ul><h3><a class="nav-anchor" id="Return-1" href="#Return-1">Return</a></h3><p>The initialize function has two return values</p><ul><li>convergence: a boolean that states whether or not convergence has been achieved after the intialization step</li><li>iterations: an int that states how many iterations were performed</li></ul><h2><a class="nav-anchor" id="Iteration-Function-1" href="#Iteration-Function-1">Iteration Function</a></h2><p>The iteration function needs the following signature</p><pre><code class="language-julia">function LS.doiteration!(linearoperator!, Q, Qrhs, solver::MyIterativeMethod, threshold, args...)
  # body of iteration
  return Bool, Int, Float
end</code></pre><h3><a class="nav-anchor" id="Arguments-2" href="#Arguments-2">Arguments</a></h3><p>The arguments to the iteration function are as follows</p><ul><li>linearoperator!: A function that is assumed to have the following signature</li></ul><pre><code class="language-julia">linearoperator!(y, x, args...)
  # body of linear operator
  return nothing
end</code></pre><p>This represents the action of a linear operator L on a vector x, that stores the value in the vector y, i.e. Lx = y. The last argument (the args...) is necessary due to how linear operators are defined in CliMa. For example, see the IMEX METHODS.</p><ul><li>Q: (array)</li><li>Qrhs: (array)</li><li>solver: (struct). This is used for dispatch onto whatever abstract iterative solver that is defined</li><li>threshold: (float). For the convergence criteria</li><li>args...: This is passed into the linearoperator! function in other parts of the CliMa code. For example, see the IMEX METHODS.</li></ul><h3><a class="nav-anchor" id="Return-2" href="#Return-2">Return</a></h3><ul><li>converged: (bool). Convergence boolean</li><li>iterations: (int). Number of iterations performed</li><li>residual_norm: (float64). Norm of the residual.</li></ul><h2><a class="nav-anchor" id="CliMa-Specific-Considerations-1" href="#CliMa-Specific-Considerations-1">CliMa Specific Considerations</a></h2><ul><li>Since GPUs have limited memory, don&#39;t take up too much memory.</li><li>By default a 3D MPI State Array has the following structure ... ,</li><li>If possible define a preconditioner. Iterative methods are typically very slow otherwise.</li></ul><h2><a class="nav-anchor" id="Preconditioners-1" href="#Preconditioners-1">Preconditioners</a></h2><p>The code needs to be slightly restructured to allow for preconditioners.</p><h2><a class="nav-anchor" id="Writing-Tests-1" href="#Writing-Tests-1">Writing Tests</a></h2><p>Test on small systems where answers can be checked analytically. Check with matrices with easily computable inverses, i.e., the identity matrix or a diagonal matrix. Test with diverse matrix structures. Test with different array types: Arrays, CuArrays, MPIStateArrays, etc. Also test with balance laws to make sure that it can actually be run with IMEX solvers on the 1) CPU 2)GPU and their distributed analogues.</p><h2><a class="nav-anchor" id="Performance-Checks-1" href="#Performance-Checks-1">Performance Checks</a></h2><p>Timing performance can be done with general GPU guidelines</p><h2><a class="nav-anchor" id="Conventions-1" href="#Conventions-1">Conventions</a></h2><ul><li>The name of the module is the name of the struct but with solver appended</li><li>Q refers to the initial guess for the iterative solver that gets overwritten with the final solution</li><li>Qrhs refers to the right hand side of the linear system</li></ul><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../../time_steppers/contribution_guide/"><span class="direction">Next</span><span class="title">Time Stepping</span></a></footer></article></body></html>
