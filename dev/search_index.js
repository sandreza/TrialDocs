var documenterSearchIndex = {"docs":
[{"location":"iterative_solvers/contribution_guide/#Contribution-Guide-for-Abstract-Iterative-Solvers-1","page":"Iterative Solvers","title":"Contribution Guide for Abstract Iterative Solvers","text":"","category":"section"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"An abstract iterative solver needs one struct, one constructor, and two functions (initialize! and doiteration!). In order to interface with the rest of CliMa. In what follows we will describe in detail the function signatures, return values, and struct properties necessary to build with CliMA.","category":"page"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"We will illustrate the method by defining a new struct","category":"page"},{"location":"iterative_solvers/contribution_guide/#Struct-1","page":"Iterative Solvers","title":"Struct","text":"","category":"section"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"A struct needs at least two members","category":"page"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"struct MyIterativeMethod{FT}\n  atol::FT\n  rtol::FT\nend","category":"page"},{"location":"iterative_solvers/contribution_guide/#Initialize-Function-1","page":"Iterative Solvers","title":"Initialize Function","text":"","category":"section"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"The initialize function needs the following signature","category":"page"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"initialize!(Q, Qrhs, args...)","category":"page"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"An example implementation (that does nothing) would be","category":"page"},{"location":"iterative_solvers/contribution_guide/#","page":"Iterative Solvers","title":"Iterative Solvers","text":"initialize!(::MyIterativeMethod)","category":"page"},{"location":"function_index/#List-of-functions-in-TrialDocs-module-1","page":"Function Index","title":"List of functions in TrialDocs module","text":"","category":"section"},{"location":"function_index/#","page":"Function Index","title":"Function Index","text":"Modules = [TrialDocs]","category":"page"},{"location":"function_index/#TrialDocs.domath-Tuple{Number}","page":"Function Index","title":"TrialDocs.domath","text":"domath(x::Number)\n\nReturn x + 5.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#TrialDocs.hello-Tuple{String}","page":"Function Index","title":"TrialDocs.hello","text":"hello(who::String)\n\nReturn \"Hello, who\".\n\n\n\n\n\n","category":"method"},{"location":"function_index/#TrialDocs.test_args-Tuple","page":"Function Index","title":"TrialDocs.test_args","text":"test_args(args...)\n\nDescription\n\nTesting to see if I can create documentation from a different folder\n\nArguments\n\nargs...: (arbitrary as long as it works with println).\n\nReturn\n\nNothing\n\nAdditional details\n\n\n\n\n\n","category":"method"},{"location":"#TrialDocs-1","page":"Home","title":"TrialDocs","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia Repo for Creating Documentation","category":"page"},{"location":"#More-Info-1","page":"Home","title":"More Info","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Just testing subsections","category":"page"}]
}
